<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-02-10 Sun 20:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Asynchronous HTTP Client - Clojure - Documentation Asynchronous HTTP Client for Clojure - Documentation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hubert Iwaniuk Chris Hapgood" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="stylesheet.css" />

<script type="text/javascript" src="org-info.js">
/**
 *
 * @source: org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in org-info.js.
 *
 * Copyright (C) 2012-2019 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "https://github.com/cch1/http.async.client");
org_html_manager.set("LINK_UP", "index.html");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="https://github.com/cch1/http.async.client"> HOME </a>
</div><div id="content">
<h1 class="title">Asynchronous HTTP Client - Clojure - Documentation Asynchronous HTTP Client for Clojure - Documentation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org31d78a1">1. Detailed documentation</a>
<ul>
<li><a href="#org4431e0d">1.1. Work modes</a>
<ul>
<li><a href="#org1bb70e9">1.1.1. Asynchronous operations</a></li>
<li><a href="#org901b30e">1.1.2. Streaming</a></li>
<li><a href="#org573e34c">1.1.3. Raw mode</a></li>
</ul>
</li>
<li><a href="#org0a7ffd7">1.2. HTTP methods</a>
<ul>
<li><a href="#org499ad86">1.2.1. GET</a></li>
<li><a href="#org921d091">1.2.2. PUT/POST</a></li>
<li><a href="#orgcf53b1b">1.2.3. DELETE</a></li>
<li><a href="#orgf2016d9">1.2.4. HEAD</a></li>
<li><a href="#org3aca6cb">1.2.5. OPTIONS</a></li>
</ul>
</li>
<li><a href="#org1541b9d">1.3. Request options</a>
<ul>
<li><a href="#orga05f983">1.3.1. :query</a></li>
<li><a href="#orga2c3727">1.3.2. :headers</a></li>
<li><a href="#org52bb861">1.3.3. :body</a></li>
<li><a href="#org2cb1be0">1.3.4. :cookies</a></li>
<li><a href="#org03a15ce">1.3.5. :proxy</a></li>
<li><a href="#org09f3bf3">1.3.6. :auth</a></li>
<li><a href="#orgc02f799">1.3.7. :timeout</a></li>
</ul>
</li>
<li><a href="#org4770d02">1.4. Streaming</a>
<ul>
<li><a href="#org7c8b4ce">1.4.1. Lazy sequence</a></li>
<li><a href="#orgb53c74f">1.4.2. Call-back</a></li>
</ul>
</li>
<li><a href="#org9cd2a54">1.5. Response handling</a>
<ul>
<li><a href="#org732794a">1.5.1. Awaiting response</a></li>
<li><a href="#org14153ec">1.5.2. Reading status line</a></li>
<li><a href="#orgd17a296">1.5.3. Is redirect?</a></li>
<li><a href="#org9118fbf">1.5.4. Reading headers</a></li>
<li><a href="#orgea1f63f">1.5.5. Reading content-type</a></li>
<li><a href="#org72e1b12">1.5.6. Reading location</a></li>
<li><a href="#orgebcadd8">1.5.7. Reading cookies</a></li>
<li><a href="#org02dc190">1.5.8. Reading body</a></li>
<li><a href="#org8097605">1.5.9. Reading body as string</a></li>
<li><a href="#org85a87ad">1.5.10. Reading error</a></li>
<li><a href="#org12043c4">1.5.11. Canceling request</a></li>
<li><a href="#org1236b90">1.5.12. Response predicates</a></li>
<li><a href="#orgc19fd1c">1.5.13. Requested URL</a></li>
</ul>
</li>
<li><a href="#orgfb03375">1.6. Managing client</a>
<ul>
<li><a href="#orgc621732">1.6.1. Branding</a></li>
<li><a href="#orga86ac44">1.6.2. Enabling HTTP compression</a></li>
<li><a href="#org651f739">1.6.3. Follow redirects</a></li>
<li><a href="#org1aa5d79">1.6.4. Keep alive</a></li>
<li><a href="#orgebffa61">1.6.5. Max connections per host</a></li>
<li><a href="#org0ee3817">1.6.6. Max connections total count</a></li>
<li><a href="#org2999b9a">1.6.7. Max redirects to follow</a></li>
<li><a href="#org9182263">1.6.8. Timeouts</a></li>
<li><a href="#org3bfc8bd">1.6.9. Proxy</a></li>
<li><a href="#org6b3d830">1.6.10. Authentication</a></li>
<li><a href="#org96a4ce2">1.6.11. SSL Certificates</a></li>
<li><a href="#org92cf056">1.6.12. Closing <b>http.async.client</b></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org783ee73">2. Low level</a>
<ul>
<li><a href="#org62f64dc">2.1. Preparing request</a></li>
<li><a href="#orge99496c">2.2. Executing request</a>
<ul>
<li><a href="#orga27e673">2.2.1. Status line</a></li>
<li><a href="#org5ba110c">2.2.2. Headers</a></li>
<li><a href="#orgd03092b">2.2.3. Body part</a></li>
<li><a href="#orgd670db0">2.2.4. Body completed</a></li>
<li><a href="#org808e938">2.2.5. Error</a></li>
</ul>
</li>
<li><a href="#org7fdac51">2.3. Default callbacks</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org31d78a1" class="outline-2">
<h2 id="org31d78a1"><span class="section-number-2">1</span> Detailed documentation</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4431e0d" class="outline-3">
<h3 id="org4431e0d"><span class="section-number-3">1.1</span> Work modes</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org1bb70e9" class="outline-4">
<h4 id="org1bb70e9"><span class="section-number-4">1.1.1</span> Asynchronous operations</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
When you do:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(http/GET &lt;client&gt; url)
</pre>
</div>
<p>
Result will be a map of <a href="http://clojuredocs.org/clojure_core/clojure.core/promise"><b>clojure.core/promise</b></a>s, and represents
response.
</p>

<p>
Following HTTP methods have been covered so far:
</p>
<ul class="org-ul">
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-GET">GET</a></li>
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-POST">POST</a></li>
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-PUT">PUT</a></li>
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-DELETE">DELETE</a></li>
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-HEAD">HEAD</a></li>
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-OPTIONS">OPTIONS</a></li>
</ul>
<p>
For detailed description see <a href="#org0a7ffd7">HTTP methods</a>.
</p>

<p>
You can submit options to HTTP methods as keyworded arguments,
like this:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(http/GET &lt;client&gt; url :query {:key "value"})
</pre>
</div>
<p>
Following options are supported:
</p>
<dl class="org-dl">
<dt><b>:query</b></dt><dd>query parameters</dd>
<dt><b>:headers</b></dt><dd>custom headers to be sent out</dd>
<dt><b>:body</b></dt><dd>body to be sent, allowed only with <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-PUT">PUT</a>/<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-POST">POST</a></dd>
<dt><b>:cookies</b></dt><dd>cookies to be sent</dd>
<dt><b>:proxy</b></dt><dd>proxy to be used</dd>
</dl>
<p>
For detailed usage of options see <a href="#org1541b9d">Request options</a>.
</p>

<p>
Response map contains following keys:
</p>
<dl class="org-dl">
<dt><b>:status</b></dt><dd>promise of lazy map of status fields
<dl class="org-dl">
<dt><b>:code</b></dt><dd>response code</dd>
<dt><b>:msg</b></dt><dd>response message</dd>
<dt><b>:protocol</b></dt><dd>protocol with version</dd>
<dt><b>:major</b></dt><dd>major version of protocol</dd>
<dt><b>:minor</b></dt><dd>minor version of protocol</dd>
</dl></dd>
<dt><b>:headers</b></dt><dd>promise of lazy map of headers where header names are
keyworded, like <b>:server</b> for example</dd>
<dt><b>:body</b></dt><dd><p>
promise of response body, this is ByteArrayOutputStream, but you
have convenience functions to convert it for example to string:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(http/string (http/GET &lt;client&gt; &lt;url&gt;))
</pre>
</div></dd>
<dt><b>:done</b></dt><dd>promise that is delivered once response receiving
is done</dd>
<dt><b>:error</b></dt><dd>promise, if there was an error you will find Throwable here</dd>
</dl>
</div>
</div>
<div id="outline-container-org901b30e" class="outline-4">
<h4 id="org901b30e"><span class="section-number-4">1.1.2</span> Streaming</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
For consuming HTTP streams use:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(http/stream-seq &lt;client&gt; :get url)
</pre>
</div>
<p>
Response here is same as in <a href="#org1bb70e9">Asynchronous operations</a> but <b>:body</b>
will be lazy sequence of ByteArrayOutputStreams.
</p>

<p>
You can still use convenience functions like <b>http/string</b> for body,
but remember that you are dealing now with <b>seq</b>.
</p>

<p>
For more details please see <a href="#org7c8b4ce">Lazy sequence</a>.
</p>
</div>
</div>
<div id="outline-container-org573e34c" class="outline-4">
<h4 id="org573e34c"><span class="section-number-4">1.1.3</span> Raw mode</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
This allows you to provide callbacks that will get triggered on HTTP
response events like:
</p>
<ul class="org-ul">
<li>received status line,</li>
<li>received headers,</li>
<li>received body part,</li>
<li>completed request,</li>
<li>handle error.</li>
</ul>
<p>
All callbacks are expected to return tuple with first element
been a value to be delivered for given response processing phase,
second element is controlling execution and if you make it
<b>:abort</b> than processing response is going to be terminated.
</p>

<p>
For detailed information on how to use this mode please see <a href="#org783ee73">Low
level</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-org0a7ffd7" class="outline-3">
<h3 id="org0a7ffd7"><span class="section-number-3">1.2</span> HTTP methods</h3>
<div class="outline-text-3" id="text-1-2">
<p>
HTTP methods and convenience functions to request them.
</p>
</div>
<div id="outline-container-org499ad86" class="outline-4">
<h4 id="org499ad86"><span class="section-number-4">1.2.1</span> GET</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Most basic invocation of <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-GET"><b>http.async.client/GET</b></a> is only with
<b>url</b> you want to get.
Extended invocation includes options that can be any options
accepted by <a href="http://cch1.github.io/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a>
[:headers :query ..].
</p>

<p>
Simple invocation:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client "&lt;your url&gt;")
	status (http/status resp)
	headers (http/headers resp)]
    (println (:code status))
    (http/await resp)
    (println (http/string resp))))
</pre>
</div>

<p>
Invocation with query parameters:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client "&lt;your url&gt;" :query {:param-name "some-value"})
	status (http/status resp)
	headers (http/headers resp)]
    (println (:code status))
    (http/await resp)
    (println (http/string resp))))
</pre>
</div>

<p>
Invocation with proxy:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client "&lt;your url&gt;"
		       :query {:param-name "some-value"}
		       :proxy {:host host :port port})
	status (http/status resp)]
    (println (:code status))
    (http/await resp)
    (println (http/string resp))))
</pre>
</div>

<p>
Invocation with cookies:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client "http://localhost:8123/cookie"
		       ;; Send cookie
		       :cookies #{{:domain "http://localhost:8123/"
				   :name "sample-name"
				   :value "sample-value"
				   :path "/cookie"
				   :max-age 10
				   :secure false}})]
    (doseq [cookie (http/cookies resp)] ; Read cookies from server response
      (println "name:" (:name cookie) ", value:" (:value cookie)))))
</pre>
</div>
<p>
Notice <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-cookies"><b>http.async.client/cookies</b></a> function extracts cookies from
response headers, so to start processing it you don't need to wait
for whole response to arrive.
</p>
</div>
</div>
<div id="outline-container-org921d091" class="outline-4">
<h4 id="org921d091"><span class="section-number-4">1.2.2</span> PUT/POST</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-PUT"><b>http.async.client/PUT</b></a>/<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-POST"><b>http.async.client/POST</b></a> work the same
way as <a href="#org499ad86"><b>GET</b></a> but they also accept <b>:body</b> argument.
</p>

<p>
<b>:body</b> can be:
</p>
<ul class="org-ul">
<li>String,</li>
<li>map, sent as form parameters,</li>
<li>vector, sent as multipart message,</li>
<li>input stream,</li>
<li>java.io.File, this will be sent using zero byte copy.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org9a7f859"></a>Submitting body as String<br />
<div class="outline-text-5" id="text-1-2-2-1">
<p>
You can send String as body with PUT/POST:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/POST client "&lt;your url&gt;" :body "SampleBody")]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</li>
<li><a id="orgdfe478b"></a>Submitting form parameters<br />
<div class="outline-text-5" id="text-1-2-2-2">
<p>
Submitting form parameters is done via body map:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/POST client "&lt;your url&gt;" :body {:u "user" :p "s3cr3t"})]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</li>
<li><a id="orgab8f60a"></a>Submitting multipart messages<br />
<div class="outline-text-5" id="text-1-2-2-3">
<p>
To send multipart messages in body use vector of maps.
Each map describes one multipart part.
</p>

<p>
Every map has to have <b>:type</b> key.
</p>

<p>
Following values for <b>:type</b> are recognized:
</p>
<dl class="org-dl">
<dt>:string</dt><dd><p>
Will send named string value in multipart part.
Map spec:
</p>
<dl class="org-dl">
<dt>:name</dt><dd><b>required</b>, name of field sent in multipart part,</dd>
<dt>:value</dt><dd><b>required</b>, value of field sent in multipart part,</dd>
<dt>:charset</dt><dd><b>optional</b>, default <b>UTF-8</b>, charset used to encode
value of field set in multipart part.</dd>
</dl>

<p>
Example of string part in use:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/POST client "&lt;your url&gt;"
			:body [{:type    :string
				:name    "field-name"
				:value   "field-value"
				:charset "UTF-8" ; this is optional,
					; and contains default value
				}])]
    ;; do something with resp
    ))
</pre>
</div></dd>
<dt>:file</dt><dd><p>
Will send named file in multipart part.
Map spec:
</p>
<dl class="org-dl">
<dt>:name</dt><dd><b>required</b>, name of field sent in multipart part,</dd>
<dt>:file</dt><dd><b>required</b>, java.io.File, whose contents will be
sent as field value,</dd>
<dt>:mime-type</dt><dd><b>required</b>, mime-type of <i>Content-Type</i> of this
multipart part.</dd>
<dt>:charset</dt><dd><b>required</b>, charset of <i>Content-Type</i> of this
multipart part.</dd>
</dl>

<p>
Example of file part in use:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/POST client "&lt;your url&gt;"
			:body [{:type      :file
				:name      "field-name"
				:file      (File. "file/to/send.txt")
				:mime-type "text/plain"
				:charset   "UTF-8"}])]
    ;; do something with resp
    ))
</pre>
</div></dd>
<dt>:bytearray</dt><dd><p>
Will send named byte array part.
</p>

<p>
Map spec:
</p>
<dl class="org-dl">
<dt>:name</dt><dd><b>required</b>, name of field sent in multipart part,</dd>
<dt>file-name</dt><dd><b>required</b>, filename of <i>Content-Disposition</i>,</dd>
<dt>data</dt><dd><b>required</b>, byte array containing data to sent as
field value,</dd>
<dt>:mime-type</dt><dd><b>required</b>, mime-type of <i>Content-Type</i> of this
multipart part.</dd>
<dt>:charset</dt><dd><b>required</b>, charset of <i>Content-Type</i> of this
multipart part.</dd>
</dl>

<p>
Example of <b>:bytearray</b> in use:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/POST client "&lt;your url&gt;"
			:body [{:type      :bytearray
				:name      "field-name"
				:file-name "file-name.txt"
				:data       (.getBytes "contents" "UTF-8")
				:mime-type  "text/plain"
				:charset    "UTF-8"}])]
    ;; do something with resp
    ))
</pre>
</div></dd>
</dl>

<p>
To send request with multiple multiparts <b>:body</b> vector needs to
contain multiple maps:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/POST client "&lt;your url&gt;"
			:body [{:type    :string
				:name    "field1-name"
				:value   "field-value"
				:charset "UTF-8" ; this is optional,
					; and contains default value
				}
			       {:type      :file
				:name      "field2-name"
				:file      (File. "file/to/send.txt")
				:mime-type "text/plain"
				:charset   "UTF-8"
				}
			       {:type      :bytearray
				:name      "field3-name"
				:file-name "file-name.txt"
				:data       (.getBytes "contents" "UTF-8")
				:mime-type  "text/plain"
				:charset    "UTF-8"}])]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</li>
<li><a id="orgb256634"></a>Submitting body as InputStream<br />
<div class="outline-text-5" id="text-1-2-2-4">
<p>
Another method to provide body is via InputStream:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(use '[clojure.java.io :only [input-stream]])
(with-open [client (http/create-client)] ; Create client
  (let [resp (http/PUT client "&lt;your url&gt;" :body (input-stream (.getBytes "SampleContent" "UTF-8")))]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</li>
<li><a id="org8c33f5d"></a>Submitting body as File, a.k.a. zero byte copy<br />
<div class="outline-text-5" id="text-1-2-2-5">
<p>
To use zero byte copy future, provide a File as :body
</p>
<div class="org-src-container">
<pre class="src src-clojure">(import '(java.io File))
(with-open [client (http/create-client)] ; Create client
  (let [resp (http/PUT "&lt;your url&gt;" :body (File. "&lt;path to file&gt;"))]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgcf53b1b" class="outline-4">
<h4 id="orgcf53b1b"><span class="section-number-4">1.2.3</span> DELETE</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
To call <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-DELETE"><b>http.async.client/DELETE</b></a> on a resource:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/DELETE "&lt;your url&gt;")]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf2016d9" class="outline-4">
<h4 id="orgf2016d9"><span class="section-number-4">1.2.4</span> HEAD</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
To call <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-HEAD"><b>http.async.client/HEAD</b></a> on a resource:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/HEAD "&lt;your url&gt;")]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org3aca6cb" class="outline-4">
<h4 id="org3aca6cb"><span class="section-number-4">1.2.5</span> OPTIONS</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
To call <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-OPTIONS"><b>http.async.client/OPTIONS</b></a> on a resource:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/OPTIONS "&lt;your url&gt;")]
    ;; do something with resp
    ))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1541b9d" class="outline-3">
<h3 id="org1541b9d"><span class="section-number-3">1.3</span> Request options</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Following options can be provided to requests and are defined by
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a>:
</p>
<dl class="org-dl">
<dt><a href="#orga05f983">:query</a></dt><dd>query parameters</dd>
<dt><a href="#orga2c3727">:headers</a></dt><dd>custom headers to be sent out</dd>
<dt><a href="#org52bb861">:body</a></dt><dd>body to be sent, allowed only with PUT/POST</dd>
<dt><a href="#org2cb1be0">:cookies</a></dt><dd>cookies to be sent</dd>
<dt><a href="#org03a15ce">:proxy</a></dt><dd>proxy to be used</dd>
<dt><a href="#org09f3bf3">:auth</a></dt><dd>authentication map</dd>
<dt><a href="#orgc02f799">:timeout</a></dt><dd>timeout configuration</dd>
</dl>
</div>
<div id="outline-container-orga05f983" class="outline-4">
<h4 id="orga05f983"><span class="section-number-4">1.3.1</span> :query</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Query parameters is a map of keywords and their values. You use
it like so:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :query {:key1 "value1" :key2 "value2"})]
    (http/await resp)
    (http/string resp)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga2c3727" class="outline-4">
<h4 id="orga2c3727"><span class="section-number-4">1.3.2</span> :headers</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Custom headers can be submitted same way as <a href="#orga05f983">:query</a>:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :headers {:header-name1 "value1"
					    :header-name2 "value2"})]
    (http/await resp)
    (http/string resp)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org52bb861" class="outline-4">
<h4 id="org52bb861"><span class="section-number-4">1.3.3</span> :body</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Body can be provided with a message only with <a href="#org921d091">PUT/POST</a>, it
doesn't make sense to have body with other <a href="#org0a7ffd7">HTTP methods</a>.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/PUT client url :body "sample body")]
    (http/await resp)
    (http/string resp)))
</pre>
</div>
<p>
<b>:body</b> can be:
</p>
<ul class="org-ul">
<li>String,</li>
<li>map, sent as form parameters,</li>
<li>vector, sent as multipart message,</li>
<li>input stream,</li>
<li>java.io.File, this will be sent using zero byte copy.</li>
</ul>

<p>
Please see <a href="#org921d091">PUT/POST</a> for more documentation.
</p>
</div>
</div>
<div id="outline-container-org2cb1be0" class="outline-4">
<h4 id="org2cb1be0"><span class="section-number-4">1.3.4</span> :cookies</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Cookies can be provided to request as follows:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client "http://localhost:8123/cookie"
		       :cookies #{{:domain "http://localhost:8123/"
				   :name "sample-name"
				   :value "sample-value"
				   :path "/cookie"
				   :max-age 10
				   :secure false}})]
    (http/await resp)
    (http/string resp)))
</pre>
</div>
<p>
<b>:cookies</b> option takes sequence of cookie maps, in this example
a hash set.
Cookie map consist of:
</p>
<dl class="org-dl">
<dt><b>:domain</b></dt><dd>Domain that cookie has been installed</dd>
<dt><b>:name</b></dt><dd>Cookie name</dd>
<dt><b>:value</b></dt><dd>Cookie value, note that there is no additional
processing so you should encode it yourself if
needed.</dd>
<dt><b>:path</b></dt><dd>Path on with cookie has been installed</dd>
<dt><b>:max-age</b></dt><dd>Max age that cookie was configured to live</dd>
<dt><b>:secure</b></dt><dd>If cookie is secure cookie</dd>
</dl>

<p>
Cookie reading is described in <a href="#orgebcadd8">Reading cookies</a>.
</p>
</div>
</div>
<div id="outline-container-org03a15ce" class="outline-4">
<h4 id="org03a15ce"><span class="section-number-4">1.3.5</span> :proxy</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Proxy can be configured per request basis as follows:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :proxy {:host h :port p})]
    (http/await resp)
    (http/string resp)))
</pre>
</div>
<p>
Proxy expects a map with following keys:
</p>
<dl class="org-dl">
<dt><b>:host</b></dt><dd>proxy host</dd>
<dt><b>:port</b></dt><dd>proxy port</dd>
<dt><b>:protocol</b></dt><dd><i>optional</i> protocol to communicate with proxy.
Can be <b>:http</b> (default) or <b>:https</b>.</dd>
<dt><b>:user</b></dt><dd><i>optional</i> user name to use for proxy authentication.
Must be provided with :password.</dd>
<dt><b>:password</b></dt><dd><i>optional</i> password to use for proxy
authentication.
Must be provided with :user.</dd>
</dl>
</div>
</div>
<div id="outline-container-org09f3bf3" class="outline-4">
<h4 id="org09f3bf3"><span class="section-number-4">1.3.6</span> :auth</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
Authentication can be configured per request basis.
For now BASIC and DIGEST methods are supported.
</p>

<p>
Basic method is default, so you don't have to specify it:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :auth {:user u :password p})]
    ;; Check if response is not 401 or so and process response
    ))
</pre>
</div>
<p>
Though you can:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :auth {:type :basic :user u :password p})]
    ;; Check if response is not 401 or so and process response
    ))
</pre>
</div>
<p>
And for digest method you will need realm as well:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url
		       :auth {:type :digest :user u :password p :realm r})]
    ;; Check if response is not 401 or so and process response
    ))
</pre>
</div>
<p>
Controlling preemptive authentication behavior is also possible:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)]
  (let [resp (http/GET client url :auth {:user u :password p :preemptive true})]
    ;; process response
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc02f799" class="outline-4">
<h4 id="orgc02f799"><span class="section-number-4">1.3.7</span> :timeout</h4>
<div class="outline-text-4" id="text-1-3-7">
<p>
Response timeout can be configured per request as well.
Timeout value is time in milliseconds in which response has to be
received.
There is special value <b>-1</b> that indicates infinite timeout.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :timeout -1)]
    (http/await resp)
    ;; process response
    ))
</pre>
</div>
<p>
Sample above will wait until response is fully received, as long
as it takes (-1 timeout).
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url :timeout 100)]
    (http/await resp)
    (if (http/failed? resp)
      ;; did not get response in configured timeout
      ;; process response
      )))
</pre>
</div>
<p>
Example above configures timeout to 100ms, so <b>await</b> will only
wait for 100ms, after that response is done.
Which doesn't necessarily mean that it was delivered to client
successfully, because it was restricted by timeout, that is why
example contains check if response has failed.
</p>
</div>
</div>
</div>
<div id="outline-container-org4770d02" class="outline-3">
<h3 id="org4770d02"><span class="section-number-3">1.4</span> Streaming</h3>
<div class="outline-text-3" id="text-1-4">
<p>
HTTP Stream is response with chunked content encoding.
Those streams might not be meant to ever finish, see twitter.com
streams, so collecting those responses as a whole is impossible,
they should be processed by response parts (chunks) as they are
been received.
</p>

<p>
Two ways of consuming a HTTP Stream are supported:
</p>
<ul class="org-ul">
<li><a href="#org7c8b4ce">Lazy sequence</a></li>
<li><a href="#orgb53c74f">Call-back</a></li>
</ul>
</div>
<div id="outline-container-org7c8b4ce" class="outline-4">
<h4 id="org7c8b4ce"><span class="section-number-4">1.4.1</span> Lazy sequence</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
You can get HTTP Stream as lazy sequence of it's body.
This is very convenient method as <b>seq</b> is native type of Clojure
so you can apply all mapping, filtering or any other standard
function that you like to it.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/stream-seq client :get url)]
    (doseq [s (http/string resp)]
      (println s))))
</pre>
</div>
<p>
<b>stream-seq</b> arguments:
</p>
<dl class="org-dl">
<dt>http method</dt><dd>any of supported methods can be used, though it
makes sense only to use <b>:get</b>, <b>:put</b> and
<b>:post</b></dd>
<dt>url</dt><dd>URL of HTTP resource</dd>
<dt>options</dt><dd>same as normal <a href="#org1541b9d">Request options</a>.</dd>
</dl>

<p>
It is important to understand that seqs returned by <b>body</b> or
<b>string</b> (which in turn calls body) are backed by queue.
One of consequences of it is that once you consumed some body
parts they will not be available anymore.
Let's see code speak for itself.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(let [resp (http/stream-seq :get url)]
  (println "1: " (first (http/string resp)))
  (println "2: " (first (http/string resp))))
</pre>
</div>
<p>
Assuming that part1 is first chunk and part2 is second.
This code will print following:
</p>
<pre class="example">
1: part1
2: part2
</pre>


<p>
Second consequence of been directly backed by queue is that you
can have multiple consumers of same response and non of them will
get same body part.
</p>

<p>
And finally this implementation is not holding to it's head.
</p>
</div>
</div>
<div id="outline-container-orgb53c74f" class="outline-4">
<h4 id="orgb53c74f"><span class="section-number-4">1.4.2</span> Call-back</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Consuming HTTP Stream with call-back is quite straight forward with
<b>http.async.client</b>. You will need to know what HTTP Method you will call,
what URL and provide a call back function to handle body parts been
received.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [parts (ref #{})
	resp (http/request-stream client :get url
				  (fn [state body]
				    (dosync (alter parts conj (string body)))
				    [body :continue]))]
    ;; do something to @parts
    ))
</pre>
</div>

<p>
Few notes on implementing body part callback:
</p>
<ul class="org-ul">
<li>state is a <b>map</b> with <b>:status</b> and <b>:headers</b> as promises, at
stage when you get called for body part, both of them should be in
place already, though it is advised to use convenience methods to
read them, see <a href="#org14153ec">Reading status line</a> and <a href="#org9118fbf">Reading headers</a>,</li>
<li>call-back has to follow guidelines described in <a href="#orgd03092b">Body part</a>,</li>
<li>some streams are not meant to be finished, in that case don't
collect body parts, as for sure you will run out of available
resources,</li>
<li>try not to do any heavy lifting in this callback, better send it
to agent.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9cd2a54" class="outline-3">
<h3 id="org9cd2a54"><span class="section-number-3">1.5</span> Response handling</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<b>http.async.client</b> exposes some convenience functions for
response handling.
</p>
</div>
<div id="outline-container-org732794a" class="outline-4">
<h4 id="org732794a"><span class="section-number-4">1.5.1</span> Awaiting response</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
If you call any of <a href="#org1bb70e9">Asynchronous operations</a>, <a href="#org901b30e">Streaming</a> or <a href="#org573e34c">Raw mode</a>
you actually asynchronously execute HTTP request.
Some times you might need to wait for response processing to be
done before proceeding, in order to do so you call
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-await"><b>http.async.client/await</b></a>.
It takes only one argument, that is response and returns once
receiving has finished.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)]
    (http/await resp)))
</pre>
</div>
<p>
Sample above will behave like synchronous HTTP operation.
For convenience it returns same response so you can use it
further, for example like that:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)]
    (http/string (http/await resp))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org14153ec" class="outline-4">
<h4 id="org14153ec"><span class="section-number-4">1.5.2</span> Reading status line</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-status"><b>http.async.client/status</b></a> returns status lazy map of response.
It will wait until HTTP Status has been received.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp   (http/GET client url)
	status (http/status resp)]
    (:code status)))
</pre>
</div>
<p>
Sample above will return HTTP response status code, notice that
after this returns headers and body, might not been delivered
yet.
</p>
</div>
</div>
<div id="outline-container-orgd17a296" class="outline-4">
<h4 id="orgd17a296"><span class="section-number-4">1.5.3</span> Is redirect?</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-redirect?"><b>http.async.client/redirect?</b></a> checks if response is redirect.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/await (http/GET client url))]
    (when (http/redirect? resp)
      (println "Response is redirect."))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9118fbf" class="outline-4">
<h4 id="org9118fbf"><span class="section-number-4">1.5.4</span> Reading headers</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-headers"><b>http.async.client/headers</b></a> returns headers lazy map of response.
It will wait until HTTP Headers are received.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp    (http/GET client url)
	headers (http/headers resp)]
    (:server headers)))
</pre>
</div>
<p>
Again, like in case of status, body might not have been delivered
yet after this returns.
</p>
</div>
</div>
<div id="outline-container-orgea1f63f" class="outline-4">
<h4 id="orgea1f63f"><span class="section-number-4">1.5.5</span> Reading content-type</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-content-type"><b>http.async.client/content-type</b></a> returns value of <b>Content-Type</b>
header.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp         (http/GET client url)
	content-type (http/content-type resp)]
    (println "Content-Type of response:" content-type)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org72e1b12" class="outline-4">
<h4 id="org72e1b12"><span class="section-number-4">1.5.6</span> Reading location</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-location"><b>http.async.client/location</b></a> will return redirect target if
response is redirect.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)
	loc  (http/location resp)]
    (println "Location of redirect:" loc)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgebcadd8" class="outline-4">
<h4 id="orgebcadd8"><span class="section-number-4">1.5.7</span> Reading cookies</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-cookies"><b>http.async.client/cookies</b></a> returns seq of maps representing
cookies.
It will wait until HTTP Headers are received.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp    (http/GET client url)
	cookies (http/cookies resp)]
    (map :name cookies)))
</pre>
</div>
<p>
Sample above will return sequence of cookie names that server has
set.
</p>
</div>
</div>
<div id="outline-container-org02dc190" class="outline-4">
<h4 id="org02dc190"><span class="section-number-4">1.5.8</span> Reading body</h4>
<div class="outline-text-4" id="text-1-5-8">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-body"><b>http.async.client/body</b></a> returns either ByteArrayOutputStream or
seq of it, depending if you used <a href="#org1bb70e9">Asynchronous operations</a> or
<a href="#org901b30e">Streaming</a> respectively.
It will <b>not</b> wait for response to be finished, it will return as
soon as first chunk of HTTP response body is received.
</p>
</div>
</div>
<div id="outline-container-org8097605" class="outline-4">
<h4 id="org8097605"><span class="section-number-4">1.5.9</span> Reading body as string</h4>
<div class="outline-text-4" id="text-1-5-9">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-string"><b>http.async.client/string</b></a> returns either string or seq of
strings, again depending if you used <a href="#org1bb70e9">Asynchronous operations</a> or
<a href="#org901b30e">Streaming</a> respectively.
It will <b>not</b> wait for response to be finished, it will return as
soon as first chunk of HTTP response body is received.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)]
    (http/string (http/await resp))))
</pre>
</div>
<p>
Sample above will return string of response body.
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-string"><b>http.async.client/string</b></a> is lazy so you can use it in case of
streams as well.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp    (http/stream-seq client :get url)
	strings (http/string resp)]
    (doseq [part strings]
      (println part))))
</pre>
</div>
<p>
Sample above will print parts as they are received, and will
return once response receiving is finished.
</p>
</div>
</div>
<div id="outline-container-org85a87ad" class="outline-4">
<h4 id="org85a87ad"><span class="section-number-4">1.5.10</span> Reading error</h4>
<div class="outline-text-4" id="text-1-5-10">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-error"><b>http.async.client/error</b></a> will return Throwable that was cause of
request failure iff request failed, else <b>nil</b>.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)]
    (http/await resp)
    (when-let [err (http/error resp)]
      (println "failed processing request: " err))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org12043c4" class="outline-4">
<h4 id="org12043c4"><span class="section-number-4">1.5.11</span> Canceling request</h4>
<div class="outline-text-4" id="text-1-5-11">
<p>
At any given time of processing HTTP Response you can <b>cancel</b> it
by calling <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-cancel"><b>http.async.client/cancel</b></a>.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)]
    (http/cancel resp)))
</pre>
</div>
<p>
Please see <b>canceling-request</b> test.
</p>
</div>
</div>
<div id="outline-container-org1236b90" class="outline-4">
<h4 id="org1236b90"><span class="section-number-4">1.5.12</span> Response predicates</h4>
<div class="outline-text-4" id="text-1-5-12">
<p>
You can also check status of request.
</p>
</div>
<ol class="org-ol">
<li><a id="org465e67f"></a>done?<br />
<div class="outline-text-5" id="text-1-5-12-1">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-done?"><b>http.async.client/done?</b></a> will tell you if response processing
has finished:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; Create client
  (let [resp (http/GET client url)]
    (when-not (http/done? resp)
      (http/await resp)
      (http/done? resp))))
</pre>
</div>
<p>
Sample above will check if response was finished, if not - will
wait for it and return true as a result of call to done?.
</p>
</div>
</li>
<li><a id="org59bfdf4"></a>failed?<br />
<div class="outline-text-5" id="text-1-5-12-2">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-failed?"><b>http.async.client/failed?</b></a> will return true iff request has
failed. If this return true you can <a href="#org85a87ad">read error</a>.
</p>
</div>
</li>
<li><a id="org386b8b1"></a>canceled?<br />
<div class="outline-text-5" id="text-1-5-12-3">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-canceled?"><b>http.async.client/canceled?</b></a> will return true iff request has
been <a href="#org12043c4">canceled</a>, else false is return.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgc19fd1c" class="outline-4">
<h4 id="orgc19fd1c"><span class="section-number-4">1.5.13</span> Requested URL</h4>
<div class="outline-text-4" id="text-1-5-13">
<p>
If you need to get the URL of the response at hand, there is an
association in it that you will find useful:
</p>
<dl class="org-dl">
<dt>:url</dt><dd>encoded url,</dd>
</dl>

<p>
And a convenience functions:
</p>
<ul class="org-ul">
<li><a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-url"><b>http.async.client/url</b></a>.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfb03375" class="outline-3">
<h3 id="orgfb03375"><span class="section-number-3">1.6</span> Managing client</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-orgc621732" class="outline-4">
<h4 id="orgc621732"><span class="section-number-4">1.6.1</span> Branding</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
<b>http.async.client</b> can be configured with User-Agent. To do so
you can use <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-create-client"><b>http.async.client/create-client</b></a> and remember to
close created client yourself, best is to use it within macro
like with-open, though make sure that body of it will wait for
whole response to finish.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :user-agent "Your User Agent/1.0")]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-orga86ac44" class="outline-4">
<h4 id="orga86ac44"><span class="section-number-4">1.6.2</span> Enabling HTTP compression</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
<b>http.async.client</b> can be configured to allow, or not, HTTP
compression.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :compression-enabled true)]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org651f739" class="outline-4">
<h4 id="org651f739"><span class="section-number-4">1.6.3</span> Follow redirects</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
Enabling HTTP redirects following.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client  (http/create-client :follow-redirects true)]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org1aa5d79" class="outline-4">
<h4 id="org1aa5d79"><span class="section-number-4">1.6.4</span> Keep alive</h4>
<div class="outline-text-4" id="text-1-6-4">
<p>
Keep Alive is enabled by default. This implies using pool for
connections.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :keep-alive true)]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgebffa61" class="outline-4">
<h4 id="orgebffa61"><span class="section-number-4">1.6.5</span> Max connections per host</h4>
<div class="outline-text-4" id="text-1-6-5">
<p>
Maximum number of connections to be cached per host.
Above this number connections will still be created but will not
be kept alive.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :max-conns-per-host 10)]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ee3817" class="outline-4">
<h4 id="org0ee3817"><span class="section-number-4">1.6.6</span> Max connections total count</h4>
<div class="outline-text-4" id="text-1-6-6">
<p>
Maximum number of total connections opened, submitting new
request while all allowed connections are active, will result in
rejection.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :max-conns-total 100)]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org2999b9a" class="outline-4">
<h4 id="org2999b9a"><span class="section-number-4">1.6.7</span> Max redirects to follow</h4>
<div class="outline-text-4" id="text-1-6-7">
<p>
Maximum number of redirects to follow.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :max-redirects 3)]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org9182263" class="outline-4">
<h4 id="org9182263"><span class="section-number-4">1.6.8</span> Timeouts</h4>
<div class="outline-text-4" id="text-1-6-8">
<p>
With <b>http.async.client</b> apart from per connection <a href="#orgc02f799">:timeout</a> you
can globally configure <b>connection</b>, <b>request</b>, <b>idle</b>, and <b>read</b>
timeouts. All timeout values are in milliseconds and magic value
<b>-1</b> is interpreted as infinite wait.
<b>idle</b> connection in pool timeout works only on connections in
pool, connections idle, for configured time, in pool will be
closed.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :connection-timeout 10
				       :request-timeout 1000
				       :read-timeout 500
				       :idle-in-pool-timeout 100)]
  (let [resp (http/GET client url)]
    ;; request processing
    ))
</pre>
</div>
<p>
Example above will timeout connection if it was not established
in 10ms, request if it was not received in 1sec, request if no bytes were
transfered for 500ms, or connection when it was idling in pool for more than 100ms.
</p>
</div>
</div>
<div id="outline-container-org3bfc8bd" class="outline-4">
<h4 id="org3bfc8bd"><span class="section-number-4">1.6.9</span> Proxy</h4>
<div class="outline-text-4" id="text-1-6-9">
<p>
Client can be also configured with global HTTP Proxy settings.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :proxy {:host h :port p})]
  (let [resp (http/GET client url)]
    ;; do stuff with resp
    ))
</pre>
</div>
<p>
Proxy expects a map with following keys:
</p>
<dl class="org-dl">
<dt><b>:host</b></dt><dd>proxy host</dd>
<dt><b>:port</b></dt><dd>proxy port</dd>
<dt><b>:protocol</b></dt><dd><i>optional</i> protocol to communicate with proxy.
Can be <b>:http</b> (default) or <b>:https</b>.</dd>
<dt><b>:user</b></dt><dd><i>optional</i> user name to use for proxy authentication.
Must be provided with :password.</dd>
<dt><b>:password</b></dt><dd><i>optional</i> password to use for proxy
authentication.
Must be provided with :user.</dd>
</dl>
</div>
</div>
<div id="outline-container-org6b3d830" class="outline-4">
<h4 id="org6b3d830"><span class="section-number-4">1.6.10</span> Authentication</h4>
<div class="outline-text-4" id="text-1-6-10">
<p>
Default authentication realm to be used globally can be
configured.
For now BASIC and DIGEST methods are supported.
</p>

<p>
Basic method is default, so you don't have to specify it:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :auth {:user u :password p})] 
  (let [resp (http/GET client url)]
    ;; Check if response is not 401 or so and process response
    ))
</pre>
</div>
<p>
Though you can:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :auth {:type :basic :user u :password p})]
  (let [resp (http/GET client url)]
    ;; Check if response is not 401 or so and process response
    ))
</pre>
</div>
<p>
And for digest method you will need realm as well:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :auth {:type :digest :user u :password p :realm r})]
  (let [resp (http/GET client url)]
    ;; Check if response is not 401 or so and process response
    ))
</pre>
</div>
<p>
Preemptive authentication can be enabled or disabled globally per client:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client :auth {:type :basic :user u :passowrd p :preemptive true})]
  (let [resp (http/GET client url)]
    ;; process response
    ))
</pre>
</div>
</div>
</div>
<div id="outline-container-org96a4ce2" class="outline-4">
<h4 id="org96a4ce2"><span class="section-number-4">1.6.11</span> SSL Certificates</h4>
<div class="outline-text-4" id="text-1-6-11">
<p>
Since v0.4.2 it is possible to use SSL certificates with client.
</p>

<p>
For client to use SSL you need to provide it with <b>ssl-context</b>.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(require [http.async.client.cert :as cert])
(let [ctx (cert/ssl-context :keystore-file ks-file
			    :keystore-password password
			    :certificate-file cert-file
			    :certificate-alias other-cert-alias)]
  (with-open [client (http/create-client :ssl-context ctx)]
    (let [resp (http/GET client url)]
      ;; process response
      )))
</pre>
</div>

<p>
For more documentation please consult docstring of
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.cert.html#var-ssl-context"><b>http.async.client.cert/ssl-context</b></a> and tests.
</p>
</div>
</div>

<div id="outline-container-org92cf056" class="outline-4">
<h4 id="org92cf056"><span class="section-number-4">1.6.12</span> Closing <b>http.async.client</b></h4>
<div class="outline-text-4" id="text-1-6-12">
<p>
Whenever you've created <b>http.async.client</b> via
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-create-client"><b>http.async.client/create-client</b></a> you will need to close it.
To do so you call <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-close"><b>http.async.client/close</b></a>.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(let [client (http/create-client)]
  (try
    (let [resp (http/GET client url)]
      ;; process response
      )
    (finally
     (http/close client))))
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org783ee73" class="outline-2">
<h2 id="org783ee73"><span class="section-number-2">2</span> Low level</h2>
<div class="outline-text-2" id="text-2">
<p>
This is lowest level access to <b>http.async.client</b>.
Mechanics here is based on asynchronous call-backs.
It provides default set of callbacks and functions to create and
execute requests.
</p>
</div>
<div id="outline-container-org62f64dc" class="outline-3">
<h3 id="org62f64dc"><span class="section-number-3">2.1</span> Preparing request</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.request.html#var-prepare-request"><b>http.async.client.request/prepare-request</b></a> is responsible for
request preparation, like the name suggests.
It takes following arguments:
</p>
<ul class="org-ul">
<li>HTTP Method like <b>:get</b> <b>:head</b></li>
<li><b>url</b> that you want to call</li>
<li><p>
and <b>options</b>, a keyworded map described already in <a href="#org1541b9d">Request options</a>.
Sample:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)]
  (let [req (request/prepare-request 
				     :get "http://google.com"
				     :headers {:my-header "value"})]
    ;; now you have request, next thing to do would be to execute it
    ))
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orge99496c" class="outline-3">
<h3 id="orge99496c"><span class="section-number-3">2.2</span> Executing request</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.request.html#var-execute-request"><b>http.async.client.request/execute-request</b></a> returns same map of promises
as <a href="#org1bb70e9">Asynchronous operations</a>.
Its arguments are: request to be executed (result of <a href="#org62f64dc">Preparing
request</a>) and <b>options</b> as keyworded map consisting of call-backs.
Following <b>options</b> keys are recognized:
</p>
<dl class="org-dl">
<dt><b>:status</b></dt><dd><a href="#orga27e673">Status line</a></dd>
<dt><b>:headers</b></dt><dd><a href="#org5ba110c">Headers</a></dd>
<dt><b>:part</b></dt><dd><a href="#orgd03092b">Body part</a></dd>
<dt><b>:completed</b></dt><dd><a href="#orgd670db0">Body completed</a></dd>
<dt><b>:error</b></dt><dd><a href="#org808e938">Error</a></dd>
</dl>
<p>
All callbacks take response map as first argument and callback
specific argument if any.
Callbacks are expected to return tuple of <b>result</b> and <b>action</b>:
</p>
<dl class="org-dl">
<dt><b>result</b></dt><dd>will be delivered to respective promise in response
map</dd>
<dt><b>action</b></dt><dd>if its value is <b>:abort</b> than response processing
will be aborted, anything else here will result in
continuation.</dd>
</dl>
</div>
<div id="outline-container-orga27e673" class="outline-4">
<h4 id="orga27e673"><span class="section-number-4">2.2.1</span> Status line</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Status line callback gets called after status line has been
received with arguments:
</p>
<ul class="org-ul">
<li>response map</li>
<li>Status map has following keys:
<ul class="org-ul">
<li><b>:code</b> status code (200, 404, ..)</li>
<li><b>:msg</b> status message ("OK", ..)</li>
<li><b>:protocol</b> protocol with version ("HTTP/1.1")</li>
<li><b>:major</b> major protocol version (1)</li>
<li><b>:minor</b> minor protocol version (0, 1)</li>
</ul></li>
</ul>

<p>
Sample code to illustrate how to use status callback:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [request (request/prepare-request :get "http://example.com") ; create request
	status (promise)                ; status promise that will be delivered by callback
	response (request/execute-request
		  client request        ; execute *request*
		  :status               ; status callback
		  (fn [res st]          ; *res* is response map, same as one returned by *execute-request*
					; *st* is status map, as described above
		    (deliver status st) ; deliver status promise
		    [st :abort]))]      ; return status to be delivered to response map and abort further processing of response.
    (println @status)))                 ; await status to be delivered and print it.
</pre>
</div>
</div>
</div>
<div id="outline-container-org5ba110c" class="outline-4">
<h4 id="org5ba110c"><span class="section-number-4">2.2.2</span> Headers</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Headers callback gets called after headers have been received
with arguments:
</p>
<ul class="org-ul">
<li>response map</li>
<li>lazy map of headers. Keys in that map are <b>(keyword
(.toLowerCase &lt;header name&gt;))</b>, so "Server" headers is
<b>:server</b> and so on.</li>
</ul>

<p>
Sample code to illustrate how to use headers callback:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [request (request/prepare-request :get "http://example.com") ; create request
	headers (promise)               ; headers promise that will be delivered by callback
	response (request/execute-request
		  client request        ; execute *request*
		  :header               ; header callback
		  (fn [res hds]         ; *res* is response map, same as one returned by *execute-request*
					; *hds* is headers map, as described above
		    (deliver headers st) ; deliver headers promise
		    [hds :abort]))]     ; return headers to be delivered to response map and abort further processing of response.
    (println @headers)))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd03092b" class="outline-4">
<h4 id="orgd03092b"><span class="section-number-4">2.2.3</span> Body part</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
Body part callback gets called after each part of body has been
received with arguments:
</p>
<ul class="org-ul">
<li>response map</li>
<li>ByteArrayOutputStream that contains body part received.</li>
</ul>

<p>
Following code sample will show how to count number of body parts
received:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [cnt (atom 0)                    ; body parts counter
	request (request/prepare-request :get "http://localhost:8123/stream") ; create request
	resp (execute-request
	      *client* request          ; execute *request*
	      :part                     ; body part callback
	      (fn [_ p]                 ; ignore response map,
					; *p* is body part
		(swap! cnt inc)         ; increment body part counter
		[p :continue]))]        ; return part to be delivered to response map and continue processing of response.
    (http/await resp)                   ; wait for response to finish
    (println @cnt)))                    ; print body parts counter
</pre>
</div>

<p>
Next sample will collect body parts:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [parts (atom #{})                ; body parts collector
	request (request/prepare-request :get "http://localhost:8123/stream") ; create request
	resp (execute-request
	      *client* request          ; execute *request*
	      :part                     ; body part callback
	      (fn [_ ^ByteArrayOutputStream p] ; ignore response map,
					; *p* is body part
		(let [p (.toString part "UTF-8")] ; extract text
		  (swap! parts conj p)  ; collect body part
		  [p :continue])))]     ; return part to be delivered to response map and continue processing of response.
    (http/await resp)                   ; wait for response to finish
    (println @parts)))                  ; print collected body parts
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd670db0" class="outline-4">
<h4 id="orgd670db0"><span class="section-number-4">2.2.4</span> Body completed</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
This callback gets called when receiving of response body has
finished with only one argument, i.e. response map.
</p>

<p>
Following snippet shows how to measure execution time:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [request (request/prepare-request :get "http://localhost:8123/") ; create request
	finished (promise)               ; execution time will be stored here
	start (System/currentTimeMillis) ; start time
	resp (execute-request
	      *client* request           ; execute *request*
	      :completed                 ; completed callback
	      (fn [_]                    ; ignore response map,
		(deliver finished        ; deliver execution time
			 (- (System/currentTimeMillis) start))))]
    (println @finished)))                ; print execution time
</pre>
</div>

<p>
You have to be aware of fact that <b>:completed</b> callback is called
only on successful response. Next snippet will show that
<b>:completed</b> callback is not called when request errors:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [request (request/prepare-request :get "http://not-existing-host/") ; create request
	finished (promise)               ; would get delivered if :completed callback would get executed
	resp (execute-request
	      *client* request           ; execute *request*
	      :completed                 ; completed callback, will not fire in this example
	      (fn [_]                    ; ignore response map,
		(deliver finished true)))] ; deliver finished promise
    (http/await resp)                    ; wait for response
    (false? (realized? finished))))      ; finished promise never got delivered
</pre>
</div>
</div>
</div>
<div id="outline-container-org808e938" class="outline-4">
<h4 id="org808e938"><span class="section-number-4">2.2.5</span> Error</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
Error callback gets called when error while processing has been
encountered with arguments
</p>
<ul class="org-ul">
<li>response map</li>
<li><b>Throwable</b> that was a cause of failure</li>
</ul>

<p>
Next code snippet shows error callback in use:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(with-open [client (http/create-client)] ; create client
  (let [request (request/prepare-request :get "http://not-existing-host/") ; create request
	errored (promise)                ; will store exception
	resp (execute-request
	      *client* request           ; execute *request*
	      :error                     ; error callback
	      (fn [_ e]                  ; ignore response map, *e* is exception
		(deliver errored e)))]   ; deliver errored promise
    (http/await resp)                    ; wait for response
    (println @errored)))                 ; print exception from callback
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7fdac51" class="outline-3">
<h3 id="org7fdac51"><span class="section-number-3">2.3</span> Default callbacks</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<a href="http://cch1.github.io/http.async.client/doc/http.async.client.request.html#var-*default-callbacks*"><b>http.async.client.request/*default-callbacks*</b></a> is a map of
default callbacks. This will allow you to easy change only few
callbacks and reuse default for the rest.
</p>

<p>
Please look at source of <a href="http://cch1.github.io/http.async.client/doc/http.async.client.html#var-stream-seq"><b>http.async.client/stream-seq</b></a> to see
how to do it.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hubert Iwaniuk Chris Hapgood</p>
<p class="date">Created: 2019-02-10 Sun 20:48</p>
<p class="creator">Emacs 24.4.1 (Org mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
